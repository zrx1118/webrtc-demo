<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <title>Document</title>
</head>
<body>
    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "../build/three.module.js",
                "three/addons/": "./jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        import { AsciiEffect } from 'three/addons/effects/AsciiEffect.js';
        import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
        
        let camera, controls, scene, renderer, effect;

        let sphere, plane;

        const start = Date.now();

        init();
        animate();

        function init() {
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.y = 500;
            camera.position.x = 500;
            // camera.position.z = 500;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0,0,0);

            const pointLight1 = new THREE.PointLight(0xffed57);
            pointLight1.position.set(500, 500, 500);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xf7f9a7, 0.95);
            pointLight2.position.set(-500, -500, -500);
            scene.add(pointLight2);

            /**
             * 球缓冲几何体（SphereGeometry）一个用于生成球体的类。
             * SphereGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)
             * radius — 球体半径，默认为1。
             * widthSegments — 水平分段数（沿着经线分段），最小值为3，默认值为32。
             * heightSegments — 垂直分段数（沿着纬线分段），最小值为2，默认值为16。
             * phiStart — 指定水平（经线）起始角度，默认值为0。。
             * phiLength — 指定水平（经线）扫描角度的大小，默认值为 Math.PI * 2。
             * thetaStart — 指定垂直（纬线）起始角度，默认值为0。
             * thetaLength — 指定垂直（纬线）扫描角度大小，默认值为 Math.PI。
            */
            /**
             * Phong网格材质(MeshPhongMaterial) 一种用于具有镜面高光的光泽表面的材质。
             * 该材质使用非物理的Blinn-Phong模型来计算反射率。 与MeshLambertMaterial中使用的Lambertian模型不同，该材质可以模拟具有镜面高光的光泽表面（例如涂漆木材）。MeshPhongMaterial uses per-fragment shading。
             * MeshPhongMaterial( parameters : Object )
             * parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。 材质的任何属性都可以从此处传入(包括从Material继承的任何属性)。
             * 属性color例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用Color.set(color)。
            */
            /**
             * 基础网格材质(MeshBasicMaterial) 一个以简单着色（平面或线框）方式来绘制几何体的材质。这种材质不受光照的影响。
             * MeshBasicMaterial( parameters : Object )
             * parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。材质的任何属性都可以从此处传入(包括从Material继承的任何属性)。
             *  flatShading 定义材质是否使用平面着色进行渲染。默认值为false。
            */
            sphere = new THREE.Mesh(new THREE.SphereGeometry(200, 72, 72), new THREE.MeshPhongMaterial({flatShading: true}))
            scene.add(sphere);
            // plane
            plane = new THREE.Mesh(new THREE.PlaneGeometry(400, 400), new THREE.MeshBasicMaterial({color: 0x6fccff}));
            plane.position.y = -200;
            plane.position.x = -Math.PI / 2;
            scene.add(plane);

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // effect = new AsciiEffect(renderer, ' .:-+*=%@#', { invert: true });
            // effect.setSize(window.innerWidth, window.innerHeight);
            // effect.domElement.style.color = 'white';
            // effect.domElement.style.backgroundColor = 'black';

            document.body.appendChild(renderer.domElement);

            controls = new TrackballControls(camera, renderer.domElement);

            // render();

            window.addEventListener('resize', onWindowResize);

        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
            effect.setSize(window.innerWidth, window.innerHeight);
            
        }

        function animate() {
            requestAnimationFrame( animate );
            render();
        }

        function render() {
            const timer = Date.now() - start;
            sphere.position.y = Math.abs(Math.sin(timer * 0.002)) * 150;
            sphere.rotation.x = timer * 0.0003;
            sphere.rotation.z = timer * 0.0002;

            controls.update();

            // effect.render(scene, camera);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>