<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="main.css">
    <style>
        a {
            color: blue;
        }
        .control-inactive button {
            color: #888;
        }
    </style>
    <title>Document</title>
</head>
<body>
    <div id="container"></div>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "../build/three.module.js",
                "three/addons/": "./jsm/",
                "models": "./models/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        import Stats from 'three/addons/libs/stats.module.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let scene, renderer, camera, stats;
        let model, skeleton, mixer, clock;

        const crossFadeControls = [];

        let currentBaseAction = 'idle';
        const allActions = [];
        const baseActions = {
            idle: { weight: 1 },
            walk: { weight: 0 },
            run: { weight: 0 }
        };
        const additiveActions = {
            sneak_pose: { weight: 0 },
            sad_pose: { weight: 0 },
            agree: { weight: 0 },
            headShake: { weight: 0 },
        };
        let panelSettings, numAnimations;

        init();
        function init() {
            const container = document.getElementById( 'container' );
            clock = new THREE.Clock();

            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0xa0a0a0 );
            /**
             * 雾（Fog）这个类中的参数定义了线性雾。也就是说，雾的密度是随着距离线性增大的。
             * Fog( color : Integer, near : Float, far : Float )
             * 颜色参数传入Color构造函数中，来设置颜色属性。颜色可以是一个十六进制的整型数，或者是CSS风格的字符串。
             * */
            scene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );

            /**
             * 半球光（HemisphereLight）光源直接放置于场景之上，光照颜色从天空光线颜色渐变到地面光线颜色。
             * HemisphereLight( skyColor : Integer, groundColor : Integer, intensity : Float )
             * skyColor -（可选）一个表示颜色的 Color 的实例、字符串或数字，默认为一个白色（0xffffff）的 Color 对象。
             * groundColor -（可选）一个表示颜色的 Color 的实例、字符串或数字，默认为一个白色（0xffffff）的 Color 对象。
             * intensity -（可选）光照强度。默认值为 1。
            */
            const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x8d8d8d );
            hemiLight.position.set( 0, 20, 0);
            scene.add( hemiLight );

            /**
             * 平行光（DirectionalLight）平行光是沿着特定方向发射的光。这种光的表现像是无限远，从它发出的光线都是平行的。常常用平行光来模拟太阳光的效果。 太阳足够远，因此我们可以认为太阳的位置是无限远，所以我们认为从太阳发出的光线也都是平行的。
             * DirectionalLight( color : Color, intensity : Float )
             * color -（可选）一个表示颜色的 Color 的实例、字符串或数字，默认为一个白色（0xffffff）的 Color 对象。
             * intensity -（可选）光照的强度。默认值为 1。
            */
            const dirLight = new THREE.DirectionalLight(0xffffff);
            dirLight.position.set(3, 10, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 2;
            dirLight.shadow.camera.bottom = -2;
            dirLight.shadow.camera.left = -2;
            dirLight.shadow.camera.right = 2;
            dirLight.shadow.camera.near = 0.1;
            dirLight.shadow.camera.far = 40;
            scene.add(dirLight);

            /**
             * 平面缓冲几何体（PlaneGeometry）
             * MeshPhongMaterial 一种用于具有镜面高光的光泽表面的材质。该材质使用非物理的Blinn-Phong模型来计算反射率。 与MeshLambertMaterial中使用的Lambertian模型不同，该材质可以模拟具有镜面高光的光泽表面（例如涂漆木材）。MeshPhongMaterial uses per-fragment shading。
            */
            const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), new THREE.MeshPhongMaterial({ color: 0xcbcbcb, depthWrite: false }))
            mesh.rotation.x = - Math.PI / 2;
            mesh.receiveShadow = true; // 材质是否接收阴影 默认值为false。
            scene.add(mesh);

            const loader = new GLTFLoader();
            loader.load('./models/gltf/Xbot.gltf', function(gltf) {
                model = gltf.scene;
                scene.add(model);

                model.traverse(function(object) {
                    if(object.isMesh) object.castShadow = true;
                });

                /**
                 * SkeletonHelper( object : Object3D ) 用来模拟骨骼 Skeleton 的辅助对象. 该辅助对象使用 LineBasicMaterial 材质.
                */
                skeleton = new THREE.SkeletonHelper(model);
                skeleton.visible = false;
                scene.add(skeleton);

                const animations = gltf.animations;
                /**
                 * AnimationMixer( rootObject : Object3D ) 动画混合器是用于场景中特定对象的动画的播放器。当场景中的多个对象独立动画时，每个对象都可以使用同一个动画混合器。
                 * rootObject - 混合器播放的动画所属的对象
                */
                mixer = new THREE.AnimationMixer(model);

                numAnimations = animations.length;

                for(let i = 0; i !== numAnimations; ++i) {
                    let clip = animations[i];
                    const name = clip.name;

                    if (baseActions[name]) {
                        const action = mixer.clipAction(clip);
                        activateAction(action);
                        baseActions[name].action = action;
                        allActions.push(action);
                    } else if (additiveActions[name]) {
                        THREE.AnimationUtils.makeClipAdditive(clip);
                        if (clip.name.endsWith('_pose')) {
                            clip = THREE.AnimationUtils.subclip( clip, clip.name, 2, 3, 30);
                        }

                        const action = mixer.clipAction(clip);
                        activateAction(action);
                        additiveActions[name].action = action;
                        allActions.push(action);
                    }
                }
                createPanel();
                animate();
            })

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.shadowMap.enabled = true;
            container.appendChild( renderer.domElement );

            // camera
            camera = new THREE.PerspectiveCamera( 45, window.innerWidth, window.innerHeight, 1, 100 );
            camera.position.set( -1, 2, 3);

            const controls = new OrbitControls( camera, renderer.domElement );
            controls.enablePan = false;
            controls.enableZoom = false;
            controls.target.set( 0, 1, 0 );
            controls.update();

            stats = new Stats();
            container.appendChild(stats.dom);

            window.addEventListener( 'resize', onWindowResize );
        }

        function createPanel() {
            const panel = new GUI({ width: 310 });
            const folder1 = panel.addFolder('Base Actions');
            const folder2 = panel.addFolder('Additive Action Weights');
            const folder3 = panel.addFolder('General Speed');

            panelSettings = {
                'modify time scale': 1.0
            }

            const baseNames = ['None', ...Object.keys(baseActions)];

            for(let i = 0, l = baseNames.length; i !== l; ++i) {
                const name = baseNames[i];
                const settings = baseActions[name];
                panelSettings[name] = function() {
                    const currentSettings = baseActions[currentBaseAction];
                    const currentAction = currentSettings ? currentSettings.action : null;
                    const action = settings ? settings.action : null;

                    if (currentAction !== action) {
                        prepareCrossFade(currentAction, action, 0.35);
                    }
                };
                crossFadeControls.push(folder1.add(panelSettings, name));
            }

            for(const name of Object.keys(additiveActions)) {
                const settings = additiveActions[name];
                panelSettings[name] = settings.weight;
                folder2.add(panelSettings, name, 0.0, 1.0, 0.01).listen().onChange(function (weight) {
                    setWeight(settings.action, weight);
                    settings.weight = weight;
                })
            }
            folder3.add(panelSettings, 'modify time scale', 0.0, 1.5, 0.01).onChange(modifyTimeScale);
            folder1.open();
            folder2.open();
            folder3.open();

            crossFadeControls.forEach(function(control) {
                control.setInactive = function () {
                    control.domElement.classList.add('control-inactive')
                };

                control.setActive = function() {
                    control.domElement.classList.remove('control-inactive');
                };

                const settings = baseActions[control.property];

                if (!settings || !settings.weight) {
                    control.setInactive();
                }
            });
        }

        function modifyTimeScale(speed) {
            mixer.speed = speed;
        }

        function prepareCrossFade(startAction, endAction, duration) {
            if (currentBaseAction === 'idle' || !startAction || !endAction) {
                executeCrossFade(startAction, endAction, duration);
            } else {
                synchronizeCrossFade(startAction, endAction, duration);
            }

            if (endAction) {
                const clip = endAction.getClip();
                currentBaseAction = clip.name;
            } else {
                currentBaseAction = 'None';
            }

            crossFadeControls.forEach(function(control) {
                const name = control.property;
                if (name === currentBaseAction) {
                    control.setActive();
                } else {
                    control.setInactive();
                }
            });
        }

        function executeCrossFade(startAction, endAction, duration) {
            if (endAction) {
                setWeight(endAction, 1);
                endAction.time = 0;

                if (startAction) {
                    startAction.crossFadeTo(endAction, duration, true);
                } else {
                    endAction.fadeIn(duration);
                }
            } else {
                // Fade out
                startAction.fadeOut(duration);
            }
        }

        function synchronizeCrossFade(startAction, endAction, duration) {
            mixer.addEventListener('loop', onLoopFinished);
            function onLoopFinished(event) {
                if (event.action === startAction) {
                    mixer.removeEventListener('loop', onLoopFinished);
                    executeCrossFade(startAction, endAction, duration);
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function activateAction(action) {
            const clip = action.getClip();
            const settings = baseActions[clip.name] || additiveActions[clip.name];
            setWeight(action, settings.weight);
            action.play();
        }

        function setWeight(action, weight) {
            action.enabled = true;
            action.setEffectiveTimeScale(1);
            action.setEffectiveWeight( weight );
        }

        function animate() {
            requestAnimationFrame(animate);
            for(let i = 0; i !== numAnimations; i++) {
                const action = allActions[i];
                const clip = action.getClip();
                const settings = baseActions[clip.name] || additiveActions[clip.name];
                settings.weight = action.getEffectiveWeight(); 
            }

            const mixerUpdateDelta = clock.getDelta();

            mixer.update(mixerUpdateDelta);
            stats.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>